<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 Ultimate</title>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <style>
        /* Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f0f0f0;
            transition: background-color 0.5s;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Theme Styles */
        .theme-retro {
            background-color: #ffdfd3;
            color: #5e2c04;
        }
        .theme-retro .board {
            background-color: #f9cb9c;
        }
        .theme-retro .cell {
            background-color: #f9f2d9;
            border: 2px solid #d0a36b;
        }
        .theme-retro .player1 {
            background-color: #ff6b6b;
            box-shadow: 0 0 10px #ff6b6b;
        }
        .theme-retro .player2 {
            background-color: #4ecdc4;
            box-shadow: 0 0 10px #4ecdc4;
        }

        .theme-cyberpunk {
            background-color: #0f0f1a;
            color: #00ff9d;
        }
        .theme-cyberpunk .board {
            background-color: #1a1a2e;
            box-shadow: 0 0 20px #00ff9d;
        }
        .theme-cyberpunk .cell {
            background-color: #16213e;
            border: 1px solid #00ff9d;
        }
        .theme-cyberpunk .player1 {
            background-color: #ff2d75;
            box-shadow: 0 0 15px #ff2d75;
        }
        .theme-cyberpunk .player2 {
            background-color: #00f0ff;
            box-shadow: 0 0 15px #00f0ff;
        }

        .theme-nature {
            background-color: #e8f4ea;
            color: #2c5e2e;
        }
        .theme-nature .board {
            background-color: #b8d8be;
        }
        .theme-nature .cell {
            background-color: #d9ead3;
            border: 2px solid #93c47d;
        }
        .theme-nature .player1 {
            background-color: #e06666;
            box-shadow: 0 0 10px #e06666;
        }
        .theme-nature .player2 {
            background-color: #6aa84f;
            box-shadow: 0 0 10px #6aa84f;
        }

        /* Menu Styles */
        .menu {
            text-align: center;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .menu h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: inherit;
        }

        .menu-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            font-size: 1.2rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            background-color: #4CAF50;
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        .btn-vs-ai {
            background-color: #2196F3;
        }

        .btn-vs-player {
            background-color: #FF5722;
        }

        .btn-theme {
            background-color: #9C27B0;
        }

        .btn-leaderboard {
            background-color: #607D8B;
        }

        /* Game Board Styles */
        .game-container {
            display: none;
            flex: 1;
            flex-direction: column;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-gap: 10px;
            padding: 20px;
            background-color: #3498db;
            border-radius: 10px;
            margin: 0 auto;
            position: relative;
        }

        .column {
            display: flex;
            flex-direction: column-reverse;
            cursor: pointer;
        }

        .cell {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 5px;
            background-color: white;
            transition: background-color 0.3s;
        }

        .player1 {
            background-color: #e74c3c;
        }

        .player2 {
            background-color: #f1c40f;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .player-turn {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .btn-back {
            background-color: #e74c3c;
        }

        /* Multiplayer Lobby Styles */
        .lobby {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .room-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 15px;
        }

        .room-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
        }

        .room-item:hover {
            background-color: #f0f0f0;
        }

        .create-room {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .create-room input {
            flex: 1;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        /* Leaderboard Styles */
        .leaderboard {
            display: none;
            flex: 1;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }

        .leaderboard h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }

        .leaderboard-table th, .leaderboard-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .leaderboard-table th {
            background-color: #f2f2f2;
        }

        /* Chat Styles */
        .chat-container {
            display: none;
            flex-direction: column;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            flex: 0.4;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .chat-input {
            display: flex;
            gap: 10px;
        }

        .chat-input input {
            flex: 1;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            margin-bottom: 20px;
        }

        .theme-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .theme-option {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }

        .theme-option:hover {
            transform: scale(1.05);
        }

        .theme-option.selected {
            border-color: #000;
        }

        .theme-retro-preview {
            background-color: #ffdfd3;
        }

        .theme-cyberpunk-preview {
            background-color: #0f0f1a;
        }

        .theme-nature-preview {
            background-color: #e8f4ea;
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .menu-options {
                flex-direction: column;
                align-items: center;
            }
            
            .cell {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body class="theme-retro">
    <div class="container">
        <!-- Main Menu -->
        <div class="menu" id="mainMenu">
            <h1>Connect 4 Ultimate</h1>
            <div class="menu-options">
                <button class="btn btn-vs-ai" id="vsAI">Play vs AI</button>
                <button class="btn btn-vs-player" id="vsPlayer">Play vs Player</button>
            </div>
            <div class="menu-options">
                <button class="btn btn-theme" id="themeBtn">Change Theme</button>
                <button class="btn btn-leaderboard" id="leaderboardBtn">Leaderboard</button>
            </div>
        </div>

        <!-- Single Player Game -->
        <div class="game-container" id="singlePlayerGame">
            <div class="game-info">
                <button class="btn btn-back" id="backFromSinglePlayer">Back to Menu</button>
                <div class="player-turn" id="singlePlayerTurn">Your turn (Red)</div>
            </div>
            <div class="board" id="singlePlayerBoard">
                <!-- Generated by JavaScript -->
            </div>
        </div>

        <!-- Multiplayer Lobby -->
        <div class="lobby" id="multiplayerLobby">
            <h2>Multiplayer Lobby</h2>
            <div class="create-room">
                <input type="text" id="roomNameInput" placeholder="Enter room name">
                <button class="btn" id="createRoomBtn">Create Room</button>
            </div>
            <div class="room-list" id="roomList">
                <!-- Rooms will be added here -->
            </div>
            <button class="btn btn-back" id="backFromLobby">Back to Menu</button>
        </div>

        <!-- Multiplayer Game -->
        <div class="game-container" id="multiplayerGame">
            <div class="game-info">
                <button class="btn btn-back" id="backFromMultiplayer">Back to Lobby</button>
                <div class="player-turn" id="multiplayerTurn">Waiting for players...</div>
            </div>
            <div class="board" id="multiplayerBoard">
                <!-- Generated by JavaScript -->
            </div>
            <div class="chat-container" id="multiplayerChat">
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type your message...">
                    <button class="btn" id="sendMessageBtn">Send</button>
                </div>
            </div>
        </div>

        <!-- Leaderboard -->
        <div class="leaderboard" id="leaderboard">
            <h2>Leaderboard</h2>
            <table class="leaderboard-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Player</th>
                        <th>Wins</th>
                        <th>Losses</th>
                        <th>Win Rate</th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody">
                    <!-- Leaderboard data will be added here -->
                </tbody>
            </table>
            <button class="btn btn-back" id="backFromLeaderboard">Back to Menu</button>
        </div>
    </div>

    <!-- Theme Selection Modal -->
    <div class="modal" id="themeModal">
        <div class="modal-content">
            <h2>Select Theme</h2>
            <div class="theme-options">
                <div class="theme-option theme-retro-preview" data-theme="retro"></div>
                <div class="theme-option theme-cyberpunk-preview" data-theme="cyberpunk"></div>
                <div class="theme-option theme-nature-preview" data-theme="nature"></div>
            </div>
            <button class="btn" id="closeThemeModal">Close</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle">Game Over</h2>
            <p id="gameOverMessage"></p>
            <button class="btn" id="playAgainBtn">Play Again</button>
            <button class="btn btn-back" id="backToMenuBtn">Back to Menu</button>
        </div>
    </div>

    <script>
        // Firebase configuration
        const firebaseConfig = {
  apiKey: "AIzaSyB0Aj452H6Gp1ociH4ufHrLiU6Uucb-ysM",
  authDomain: "who-is-the-spy-51308.firebaseapp.com",
  databaseURL: "https://who-is-the-spy-51308-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "who-is-the-spy-51308",
  storageBucket: "who-is-the-spy-51308.firebasestorage.app",
  messagingSenderId: "900253646275",
  appId: "1:900253646275:web:b9f7a3cbb1069a07d2d176",
  measurementId: "G-NWXDDDRPRH"
};
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();

        // Game state variables
        let currentGameMode = null; // 'single' or 'multiplayer'
        let currentPlayer = 1; // 1 or 2
        let gameBoard = [];
        let gameActive = false;
        let currentTheme = 'retro';
        let currentRoomId = null;
        let playerNumber = null; // 1 or 2 in multiplayer
        let playerName = "Player" + Math.floor(Math.random() * 1000);
        let aiDifficulty = "medium"; // easy, medium, hard

        // DOM elements
        const mainMenu = document.getElementById('mainMenu');
        const singlePlayerGame = document.getElementById('singlePlayerGame');
        const multiplayerLobby = document.getElementById('multiplayerLobby');
        const multiplayerGame = document.getElementById('multiplayerGame');
        const leaderboard = document.getElementById('leaderboard');
        const themeModal = document.getElementById('themeModal');
        const gameOverModal = document.getElementById('gameOverModal');
        const roomList = document.getElementById('roomList');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');

        // Initialize the game
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            initializeBoard('singlePlayerBoard');
            initializeBoard('multiplayerBoard');
            checkAuthState();
        });

        function checkAuthState() {
            auth.onAuthStateChanged(user => {
                if (user) {
                    playerName = user.displayName || playerName;
                } else {
                    // Optional: Implement anonymous or Google sign-in
                    // auth.signInAnonymously().catch(error => console.error(error));
                }
            });
        }

        function setupEventListeners() {
            // Main menu buttons
            document.getElementById('vsAI').addEventListener('click', () => startSinglePlayerGame());
            document.getElementById('vsPlayer').addEventListener('click', () => showMultiplayerLobby());
            document.getElementById('themeBtn').addEventListener('click', () => showThemeModal());
            document.getElementById('leaderboardBtn').addEventListener('click', () => showLeaderboard());

            // Navigation buttons
            document.getElementById('backFromSinglePlayer').addEventListener('click', () => returnToMenu());
            document.getElementById('backFromLobby').addEventListener('click', () => returnToMenu());
            document.getElementById('backFromMultiplayer').addEventListener('click', () => leaveMultiplayerGame());
            document.getElementById('backFromLeaderboard').addEventListener('click', () => returnToMenu());
            document.getElementById('backToMenuBtn').addEventListener('click', () => returnToMenu());

            // Theme modal
            document.querySelectorAll('.theme-option').forEach(option => {
                option.addEventListener('click', () => {
                    const theme = option.dataset.theme;
                    changeTheme(theme);
                });
            });
            document.getElementById('closeThemeModal').addEventListener('click', () => {
                themeModal.style.display = 'none';
            });

            // Game over modal
            document.getElementById('playAgainBtn').addEventListener('click', () => {
                gameOverModal.style.display = 'none';
                if (currentGameMode === 'single') {
                    resetSinglePlayerGame();
                } else {
                    resetMultiplayerGame();
                }
            });

            // Multiplayer lobby
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('sendMessageBtn').addEventListener('click', sendChatMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChatMessage();
            });
        }

        function showThemeModal() {
            themeModal.style.display = 'flex';
        }

        function changeTheme(theme) {
            currentTheme = theme;
            document.body.className = `theme-${theme}`;
            themeModal.style.display = 'none';
            // Save theme preference to localStorage
            localStorage.setItem('connect4-theme', theme);
        }

        function initializeBoard(boardId) {
            const board = document.getElementById(boardId);
            board.innerHTML = '';
            
            // Create columns
            for (let col = 0; col < 7; col++) {
                const column = document.createElement('div');
                column.className = 'column';
                column.dataset.column = col;
                
                // Create cells for each column (now in correct order)
                for (let row = 0; row < 6; row++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.column = col;
                    column.appendChild(cell);
                }
                
                board.appendChild(column);
            }

            // Add event listeners for column clicks
            const columns = board.querySelectorAll('.column');
            columns.forEach(column => {
                column.addEventListener('click', () => {
                    const col = parseInt(column.dataset.column);
                    if (boardId === 'singlePlayerBoard' && currentGameMode === 'single' && gameActive && currentPlayer === 1) {
                        makeMove(col);
                    } else if (boardId === 'multiplayerBoard' && currentGameMode === 'multiplayer' && gameActive && currentPlayer === playerNumber) {
                        makeMultiplayerMove(col);
                    }
                });
            });
        }

        function startSinglePlayerGame() {
            currentGameMode = 'single';
            mainMenu.style.display = 'none';
            singlePlayerGame.style.display = 'flex';
            leaderboard.style.display = 'none';
            
            resetSinglePlayerGame();
        }

        function resetSinglePlayerGame() {
            // Initialize empty board
            gameBoard = Array(6).fill().map(() => Array(7).fill(0));
            currentPlayer = 1;
            gameActive = true;
            
            // Update UI
            document.getElementById('singlePlayerTurn').textContent = 'Your turn (Red)';
            
            // Clear board visually
            const cells = document.querySelectorAll('#singlePlayerBoard .cell');
            cells.forEach(cell => {
                cell.classList.remove('player1', 'player2');
            });
        }

        function makeMove(col) {
            if (!gameActive) return;
            
            // Find the lowest empty row in the selected column (changed from highest)
            let row = -1;
            for (let r = 0; r < 6; r++) {
                if (gameBoard[r][col] === 0) {
                    row = r;
                    break;
                }
            }
            
            if (row === -1) return; // Column is full
            
            // Update game state
            gameBoard[row][col] = currentPlayer;
            
            // Update UI
            const cell = document.querySelector(`#singlePlayerBoard .cell[data-row="${row}"][data-column="${col}"]`);
            cell.classList.add(`player${currentPlayer}`);
            // Check for win
     // Check for win
     if (checkWin(row, col)) {
                gameActive = false;
                showGameOver(`Player ${currentPlayer} wins!`);
                updateLeaderboard(currentPlayer === 1 ? 'win' : 'loss');
                return;
            }
            
            // Check for draw
            if (checkDraw()) {
                gameActive = false;
                showGameOver("It's a draw!");
                return;
            }
            // Switch player
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            document.getElementById('singlePlayerTurn').textContent = currentPlayer === 1 ? 'Your turn (Red)' : 'AI thinking...';
            
            // If it's AI's turn, make AI move
            if (currentPlayer === 2) {
                setTimeout(() => makeAIMove(), 1000);
            }
        }

        function makeAIMove() {
            if (!gameActive) return;
            
            let col;
            switch (aiDifficulty) {
                case 'easy':
                    col = makeRandomMove();
                    break;
                case 'medium':
                    if (Math.random() < 0.7) {
                        col = findWinningMove(2) || findBlockingMove() || makeStrategicMove() || makeRandomMove();
                    } else {
                        col = makeRandomMove();
                    }
                    break;
                case 'hard':
                    col = findWinningMove(2) || findBlockingMove() || makeStrategicMove() || makeRandomMove();
                    break;
                default:
                    col = makeRandomMove();
            }
            
            makeMove(col);
        }

        function makeRandomMove() {
            const availableCols = [];
            for (let c = 0; c < 7; c++) {
                if (gameBoard[0][c] === 0) {
                    availableCols.push(c);
                }
            }
            return availableCols[Math.floor(Math.random() * availableCols.length)];
        }

        function findWinningMove(player) {
            // Check for immediate winning move
            for (let c = 0; c < 7; c++) {
                if (gameBoard[0][c] !== 0) continue; // Column is full
                
                // Find the row where the piece would land
                let r;
                for (r = 5; r >= 0; r--) {
                    if (gameBoard[r][c] === 0) break;
                }
                
                // Temporarily make the move
                gameBoard[r][c] = player;
                
                // Check if this move wins
                if (checkWin(r, c)) {
                    // Undo the temporary move
                    gameBoard[r][c] = 0;
                    return c;
                }
                
                // Undo the temporary move
                gameBoard[r][c] = 0;
            }
            
            return null;
        }

        function findBlockingMove() {
            // Check if opponent has an immediate winning move and block it
            return findWinningMove(1);
        }

        function makeStrategicMove() {
            // Prefer center columns
            const centerPreference = [3, 2, 4, 1, 5, 0, 6];
            for (const c of centerPreference) {
                if (gameBoard[0][c] === 0) {
                    return c;
                }
            }
            return null;
        }

        function checkWin(row, col) {
            const player = gameBoard[row][col];
            
            // Check horizontal
            let count = 1;
            // Left
            for (let c = col - 1; c >= 0 && gameBoard[row][c] === player; c--) count++;
            // Right
            for (let c = col + 1; c < 7 && gameBoard[row][c] === player; c++) count++;
            if (count >= 4) return true;
            
            // Check vertical
            count = 1;
            // Down
            for (let r = row + 1; r < 6 && gameBoard[r][col] === player; r++) count++;
            // Up is not needed since we always place at the bottom
            if (count >= 4) return true;
            
            // Check diagonal (top-left to bottom-right)
            count = 1;
            // Up-left
            for (let r = row - 1, c = col - 1; r >= 0 && c >= 0 && gameBoard[r][c] === player; r--, c--) count++;
            // Down-right
            for (let r = row + 1, c = col + 1; r < 6 && c < 7 && gameBoard[r][c] === player; r++, c++) count++;
            if (count >= 4) return true;
            
            // Check diagonal (top-right to bottom-left)
            count = 1;
            // Up-right
            for (let r = row - 1, c = col + 1; r >= 0 && c < 7 && gameBoard[r][c] === player; r--, c++) count++;
            // Down-left
            for (let r = row + 1, c = col - 1; r < 6 && c >= 0 && gameBoard[r][c] === player; r++, c--) count++;
            if (count >= 4) return true;
            
            return false;
        }

        function checkDraw() {
            // Check if top row is full
            return gameBoard[0].every(cell => cell !== 0);
        }

        function showGameOver(message) {
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverTitle').textContent = message.includes('wins') ? 'You Win!' : 'Game Over';
            gameOverModal.style.display = 'flex';
        }

        function showMultiplayerLobby() {
            currentGameMode = 'multiplayer';
            mainMenu.style.display = 'none';
            multiplayerLobby.style.display = 'flex';
            singlePlayerGame.style.display = 'none';
            multiplayerGame.style.display = 'none';
            leaderboard.style.display = 'none';
            
            loadRooms();
        }

        function loadRooms() {
            roomList.innerHTML = '<p>Loading rooms...</p>';
            
            database.ref('rooms').on('value', snapshot => {
                const rooms = snapshot.val();
                roomList.innerHTML = '';
                
                if (!rooms || Object.keys(rooms).length === 0) {
                    roomList.innerHTML = '<p>No rooms available. Create one!</p>';
                    return;
                }
                
                for (const roomId in rooms) {
                    const room = rooms[roomId];
                    const roomItem = document.createElement('div');
                    roomItem.className = 'room-item';
                    roomItem.innerHTML = `
                        <div>
                            <strong>${room.name}</strong>
                            <span>${room.player1 ? '1/2' : '0/2'} players</span>
                        </div>
                        <div>${room.status || 'Waiting'}</div>
                    `;
                    roomItem.addEventListener('click', () => joinRoom(roomId, room));
                    roomList.appendChild(roomItem);
                }
            });
        }

        function createRoom() {
            const roomName = document.getElementById('roomNameInput').value.trim() || `${playerName}'s Game`;
            
            const newRoomRef = database.ref('rooms').push();
            const roomId = newRoomRef.key;
            
            newRoomRef.set({
                name: roomName,
                player1: playerName,
                player2: null,
                board: Array(6).fill().map(() => Array(7).fill(0)),
                currentPlayer: 1,
                status: 'waiting',
                createdAt: firebase.database.ServerValue.TIMESTAMP
            }).then(() => {
                joinRoom(roomId, {
                    name: roomName,
                    player1: playerName,
                    player2: null,
                    status: 'waiting'
                });
            });
        }

        function joinRoom(roomId, roomData) {
            currentRoomId = roomId;
            playerNumber = roomData.player1 && !roomData.player2 ? 2 : 1;
            
            if (playerNumber === 2) {
                // Join as player 2
                database.ref(`rooms/${roomId}`).update({
                    player2: playerName,
                    status: 'playing'
                });
            }
            
            // Set up room listeners
            setupRoomListeners(roomId);
            
            // Show game screen
            multiplayerLobby.style.display = 'none';
            multiplayerGame.style.display = 'flex';
            
            // Update game info
            document.getElementById('multiplayerTurn').textContent = 
                `You are ${playerNumber === 1 ? 'Red' : 'Yellow'} (Player ${playerNumber})`;
            
            // Initialize board from room data
            updateMultiplayerBoard(roomData.board || Array(6).fill().map(() => Array(7).fill(0)));
            gameActive = roomData.status === 'playing';
        }

        function setupRoomListeners(roomId) {
            // Listen for room updates
            database.ref(`rooms/${roomId}`).on('value', snapshot => {
                const room = snapshot.val();
                if (!room) {
                    // Room was deleted
                    alert('The room has been closed by the host.');
                    leaveMultiplayerGame();
                    return;
                }
                
                // Update board
                updateMultiplayerBoard(room.board);
                
                // Update game status
                if (room.status === 'gameover') {
                    gameActive = false;
                    const winner = room.winner;
                    if (winner) {
                        showGameOver(`Player ${winner} (${winner === 1 ? room.player1 : room.player2}) wins!`);
                        if (winner === playerNumber) {
                            updateLeaderboard('win');
                        } else {
                            updateLeaderboard('loss');
                        }
                    } else {
                        showGameOver("It's a draw!");
                    }
                } else {
                    gameActive = room.status === 'playing';
                    currentPlayer = room.currentPlayer;
                    
                    document.getElementById('multiplayerTurn').textContent = 
                        room.currentPlayer === playerNumber ? 
                        `Your turn (${playerNumber === 1 ? 'Red' : 'Yellow'})` : 
                        `Waiting for ${room.currentPlayer === 1 ? room.player1 : room.player2}'s move`;
                }
            });
            
            // Listen for chat messages
            database.ref(`rooms/${roomId}/messages`).on('child_added', snapshot => {
                const message = snapshot.val();
                addChatMessage(message.sender, message.text, message.timestamp);
            });
        }

        function updateMultiplayerBoard(board) {
            gameBoard = board;
            
            // Update UI
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.querySelector(`#multiplayerBoard .cell[data-row="${row}"][data-column="${col}"]`);
                    cell.classList.remove('player1', 'player2');
                    if (board[row][col] === 1) cell.classList.add('player1');
                    if (board[row][col] === 2) cell.classList.add('player2');
                }
            }
        }

        function makeMultiplayerMove(col) {
            if (!gameActive || currentPlayer !== playerNumber) return;
            
            // Find the lowest empty row in the selected column (changed from highest)
            let row = -1;
            for (let r = 0; r < 6; r++) {
                if (gameBoard[r][col] === 0) {
                    row = r;
                    break;
                }
            }
            
            if (row === -1) return; // Column is full
            
            // Update game state in Firebase
            const updates = {};
            updates[`rooms/${currentRoomId}/board/${row}/${col}`] = playerNumber;
            updates[`rooms/${currentRoomId}/currentPlayer`] = playerNumber === 1 ? 2 : 1;
            
            database.ref().update(updates).then(() => {
                // Check for win or draw (this should be handled by the room listener)
                const newBoard = JSON.parse(JSON.stringify(gameBoard));
                newBoard[row][col] = playerNumber;
                
                if (checkWin(row, col, newBoard)) {
                    database.ref(`rooms/${currentRoomId}`).update({
                        status: 'gameover',
                        winner: playerNumber
                    });
                } else if (checkDraw(newBoard)) {
                    database.ref(`rooms/${currentRoomId}`).update({
                        status: 'gameover',
                        winner: null
                    });
                }
            });
        }

        function checkWin(row, col, board = gameBoard) {
            const player = board[row][col];
            
            // Check horizontal
            let count = 1;
            // Left
            for (let c = col - 1; c >= 0 && board[row][c] === player; c--) count++;
            // Right
            for (let c = col + 1; c < 7 && board[row][c] === player; c++) count++;
            if (count >= 4) return true;
            
            // Check vertical
            count = 1;
            // Down
            for (let r = row + 1; r < 6 && board[r][col] === player; r++) count++;
            // Up is not needed since we always place at the bottom
            if (count >= 4) return true;
            
            // Check diagonal (top-left to bottom-right)
            count = 1;
            // Up-left
            for (let r = row - 1, c = col - 1; r >= 0 && c >= 0 && board[r][c] === player; r--, c--) count++;
            // Down-right
            for (let r = row + 1, c = col + 1; r < 6 && c < 7 && board[r][c] === player; r++, c++) count++;
            if (count >= 4) return true;
            
            // Check diagonal (top-right to bottom-left)
            count = 1;
            // Up-right
            for (let r = row - 1, c = col + 1; r >= 0 && c < 7 && board[r][c] === player; r--, c++) count++;
            // Down-left
            for (let r = row + 1, c = col - 1; r < 6 && c >=0 && board[r][c] === player; r++, c--) count++;
            if (count >= 4) return true; return false;
    }

    function checkDraw(board = gameBoard) {
        // Check if top row is full
        return board[0].every(cell => cell !== 0);
    }

    function leaveMultiplayerGame() {
        if (currentRoomId) {
            // Remove player from room
            const updates = {};
            if (playerNumber === 1) {
                updates[`rooms/${currentRoomId}/player1`] = null;
                // If game was in progress, player 2 wins by default
                if (gameActive) {
                    updates[`rooms/${currentRoomId}/status`] = 'gameover';
                    updates[`rooms/${currentRoomId}/winner`] = 2;
                    updateLeaderboard('loss');
                }
            } else {
                updates[`rooms/${currentRoomId}/player2`] = null;
            }
            
            // If both players left, delete the room
            database.ref(`rooms/${currentRoomId}`).once('value').then(snapshot => {
                const room = snapshot.val();
                if ((!room.player1 && !room.player2) || (!room.player1 && room.player2 && playerNumber === 1)) {
                    database.ref(`rooms/${currentRoomId}`).remove();
                    database.ref(`rooms/${currentRoomId}/messages`).remove();
                } else {
                    database.ref().update(updates);
                }
            });
            
            currentRoomId = null;
        }
        
        returnToMenu();
    }

    function resetMultiplayerGame() {
        if (!currentRoomId) return;
        
        database.ref(`rooms/${currentRoomId}`).update({
            board: Array(6).fill().map(() => Array(7).fill(0)),
            currentPlayer: 1,
            status: 'playing',
            winner: null
        });
    }

    function sendChatMessage() {
        const message = chatInput.value.trim();
        if (!message || !currentRoomId) return;
        
        const newMessage = {
            sender: playerName,
            text: message,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        database.ref(`rooms/${currentRoomId}/messages`).push(newMessage);
        chatInput.value = '';
    }

    function addChatMessage(sender, text, timestamp) {
        const messageElement = document.createElement('div');
        messageElement.innerHTML = `<strong>${sender}:</strong> ${text}`;
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function showLeaderboard() {
        mainMenu.style.display = 'none';
        singlePlayerGame.style.display = 'none';
        multiplayerLobby.style.display = 'none';
        multiplayerGame.style.display = 'none';
        leaderboard.style.display = 'block';
        
        loadLeaderboard();
    }

    function loadLeaderboard() {
        database.ref('leaderboard').orderByChild('wins').limitToLast(10).once('value').then(snapshot => {
            const leaderboardData = snapshot.val();
            const leaderboardBody = document.getElementById('leaderboardBody');
            leaderboardBody.innerHTML = '';
            
            if (!leaderboardData) {
                leaderboardBody.innerHTML = '<tr><td colspan="5">No data available</td></tr>';
                return;
            }
            
            // Convert to array and sort
            const players = [];
            for (const id in leaderboardData) {
                players.push({
                    id,
                    ...leaderboardData[id]
                });
            }
            
            players.sort((a, b) => b.wins - a.wins || a.losses - b.losses);
            
            // Display top 10
            players.slice(0, 10).forEach((player, index) => {
                const row = document.createElement('tr');
                const winRate = player.wins + player.losses > 0 ? 
                    Math.round((player.wins / (player.wins + player.losses)) * 100) : 0;
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${player.name}</td>
                    <td>${player.wins}</td>
                    <td>${player.losses}</td>
                    <td>${winRate}%</td>
                `;
                leaderboardBody.appendChild(row);
            });
        });
    }

    function updateLeaderboard(result) {
        if (!playerName) return;
        
        // Try to find existing player record
        database.ref('leaderboard').orderByChild('name').equalTo(playerName).once('value').then(snapshot => {
            const updates = {};
            let playerId;
            
            if (snapshot.exists()) {
                // Update existing record
                const playerData = snapshot.val();
                playerId = Object.keys(playerData)[0];
                const currentWins = playerData[playerId].wins || 0;
                const currentLosses = playerData[playerId].losses || 0;
                
                updates[`leaderboard/${playerId}/wins`] = result === 'win' ? currentWins + 1 : currentWins;
                updates[`leaderboard/${playerId}/losses`] = result === 'loss' ? currentLosses + 1 : currentLosses;
            } else {
                // Create new record
                playerId = database.ref('leaderboard').push().key;
                updates[`leaderboard/${playerId}`] = {
                    name: playerName,
                    wins: result === 'win' ? 1 : 0,
                    losses: result === 'loss' ? 1 : 0
                };
            }
            
            database.ref().update(updates);
        });
    }

    function returnToMenu() {
        mainMenu.style.display = 'block';
        singlePlayerGame.style.display = 'none';
        multiplayerLobby.style.display = 'none';
        multiplayerGame.style.display = 'none';
        leaderboard.style.display = 'none';
        gameOverModal.style.display = 'none';
        themeModal.style.display = 'none';
        
        // Clean up Firebase listeners
        if (currentRoomId) {
            database.ref(`rooms/${currentRoomId}`).off();
            database.ref(`rooms/${currentRoomId}/messages`).off();
            currentRoomId = null;
        }
        
        currentGameMode = null;
        gameActive = false;
    }

    // Load saved theme preference
    const savedTheme = localStorage.getItem('connect4-theme');
    if (savedTheme) {
        changeTheme(savedTheme);
    }
</script>
<body>
    <html>
